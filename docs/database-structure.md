# Структура базы данных CURSED - Auto Repair Tracking System

## Таблица 1 – Назначение таблиц базы данных

| Таблица | Назначение |
|---------|-----------|
| User | Хранение информации о пользователях системы, включая email, пароль, ФИО, телефон и роль (клиент, механик или администратор). |
| VehicleBrand | Хранение информации о марках автомобилей. |
| VehicleModel | Хранение информации о моделях автомобилей. |
| VehicleGeneration | Хранение информации о поколениях автомобилей с диапазоном годов выпуска. |
| ServiceTemplate | Хранение шаблонов услуг (диагностика, ремонт, ТО и т.д.). |
| StageTemplate | Хранение шаблонов этапов ремонта для каждой услуги. |
| Order | Хранение информации о заказах клиентов на ремонт или обслуживание автомобилей. |
| OrderStage | Хранение информации об этапах выполнения конкретного заказа. |
| StageComment | Хранение комментариев к этапам ремонта от механиков и администраторов. |
| StageAttachment | Хранение файлов и фотографий, прикрепленных к этапам ремонта. |
| InventoryItem | Хранение информации о комплектующих и расходных материалах на складе. |
| InventoryItemCompatibility | Хранение информации о совместимости комплектующих с конкретными моделями автомобилей. |
| InventoryItemCrossReference | Хранение кросс-ссылок на аналоги и замены комплектующих. |
| StageTemplateInventoryItem | Хранение рекомендуемых комплектующих для шаблонов этапов. |
| OrderStageInventoryItem | Хранение комплектующих, предложенных администратором и выбранных клиентом для конкретного этапа заказа. |
| OrderInventoryItem | Хранение общих комплектующих заказа (для обратной совместимости). |
| Notification | Хранение уведомлений пользователей о событиях в системе. |

---

## Таблица 2 – Структура таблицы User

Таблица User содержит информацию о пользователях системы. Описание полей таблицы представлено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор пользователя. |
| email | varchar | Email пользователя (уникальный). |
| passwordHash | varchar | Хэш пароля пользователя. |
| fullName | varchar | Полное имя пользователя. |
| phone | varchar | Номер телефона пользователя (необязательно). |
| role | varchar | Роль пользователя: «client», «mechanic» или «admin». По умолчанию «client». |
| isActive | boolean | Статус активности учетной записи. По умолчанию true. |
| createdAt | datetime | Дата и время создания пользователя. |
| updatedAt | datetime | Дата и время последнего обновления данных пользователя. |

---

## Таблица 3 – Структура таблицы VehicleBrand

Таблица VehicleBrand содержит информацию о марках автомобилей. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор марки автомобиля. |
| name | varchar | Название марки на английском языке (уникальное). |
| nameRu | varchar | Название марки на русском языке (необязательно). |
| logoUrl | varchar | URL логотипа марки (необязательно). |
| isActive | boolean | Статус активности марки. По умолчанию true. |
| createdAt | datetime | Дата и время создания записи. |
| updatedAt | datetime | Дата и время последнего обновления записи. |

---

## Таблица 4 – Структура таблицы VehicleModel

Таблица VehicleModel содержит информацию о моделях автомобилей. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор модели автомобиля. |
| brandId | uuid | Идентификатор марки автомобиля, к которой принадлежит модель. |
| name | varchar | Название модели на английском языке. |
| nameRu | varchar | Название модели на русском языке (необязательно). |
| isActive | boolean | Статус активности модели. По умолчанию true. |
| createdAt | datetime | Дата и время создания записи. |
| updatedAt | datetime | Дата и время последнего обновления записи. |

---

## Таблица 5 – Структура таблицы VehicleGeneration

Таблица VehicleGeneration содержит информацию о поколениях автомобилей с указанием диапазона годов выпуска. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор поколения автомобиля. |
| modelId | uuid | Идентификатор модели автомобиля, к которой принадлежит поколение. |
| name | varchar | Название поколения на английском языке. |
| nameRu | varchar | Название поколения на русском языке (необязательно). |
| yearFrom | int | Год начала выпуска данного поколения (необязательно). |
| yearTo | int | Год окончания выпуска данного поколения (необязательно). |
| isActive | boolean | Статус активности поколения. По умолчанию true. |
| createdAt | datetime | Дата и время создания записи. |
| updatedAt | datetime | Дата и время последнего обновления записи. |

---

## Таблица 6 – Структура таблицы ServiceTemplate

Таблица ServiceTemplate содержит информацию о шаблонах услуг. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор шаблона услуги. |
| name | varchar | Название шаблона услуги. |
| description | varchar | Описание шаблона услуги (необязательно). |
| isActive | boolean | Статус активности шаблона. По умолчанию true. |
| createdAt | datetime | Дата и время создания записи. |
| updatedAt | datetime | Дата и время последнего обновления записи. |

---

## Таблица 7 – Структура таблицы StageTemplate

Таблица StageTemplate содержит информацию о шаблонах этапов ремонта для каждой услуги. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор шаблона этапа. |
| serviceTemplateId | uuid | Идентификатор шаблона услуги, к которому относится этап. |
| name | varchar | Название этапа. |
| description | varchar | Описание этапа (необязательно). |
| orderIndex | int | Порядковый номер этапа. |
| estimatedHours | float | Приблизительное время выполнения в часах (необязательно). |
| isRequired | boolean | Обязательный ли данный этап. По умолчанию true. |
| createdAt | datetime | Дата и время создания записи. |
| updatedAt | datetime | Дата и время последнего обновления записи. |

---

## Таблица 8 – Структура таблицы Order

Таблица Order содержит информацию о заказах клиентов на ремонт или обслуживание автомобилей. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор заказа. |
| title | varchar | Название заказа. |
| description | varchar | Описание проблемы или работ (необязательно). |
| customerId | uuid | Идентификатор клиента, создавшего заказ. |
| vehicleGenerationId | uuid | Идентификатор поколения автомобиля (необязательно). |
| vehicleYear | int | Год выпуска автомобиля (необязательно). |
| vehicleInfo | varchar | Дополнительная информация об автомобиле (необязательно). |
| vinNumber | varchar | VIN-номер автомобиля (необязательно). |
| serviceType | varchar | Тип работы: «diagnostics», «repair», «maintenance» или «other». |
| serviceTypeOther | varchar | Описание типа работы, если выбран «other» (необязательно). |
| status | varchar | Статус заказа: «pending», «in_progress», «completed» и т.д. По умолчанию «pending». |
| createdAt | datetime | Дата и время создания заказа. |
| updatedAt | datetime | Дата и время последнего обновления заказа. |
| completedAt | datetime | Дата и время завершения заказа (необязательно). |
| adminLastViewedAt | datetime | Дата и время последнего просмотра администратором (необязательно). |
| serviceTemplateId | uuid | Идентификатор шаблона услуги (необязательно). |

---

## Таблица 9 – Структура таблицы OrderStage

Таблица OrderStage содержит информацию об этапах выполнения конкретного заказа. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор этапа заказа. |
| orderId | uuid | Идентификатор заказа, к которому относится этап. |
| stageTemplateId | uuid | Идентификатор шаблона этапа (необязательно). |
| name | varchar | Название этапа. |
| description | varchar | Описание этапа (необязательно). |
| status | varchar | Статус этапа: «pending», «in_progress», «done» и т.д. По умолчанию «pending». |
| assignedTo | uuid | Идентификатор механика, назначенного на этап (необязательно). |
| startedAt | datetime | Дата и время начала выполнения этапа (необязательно). |
| completedAt | datetime | Дата и время завершения этапа (необязательно). |
| orderIndex | int | Порядковый номер этапа в заказе. |
| lastViewedAt | datetime | Дата и время последнего просмотра этапа (необязательно). |
| createdAt | datetime | Дата и время создания этапа. |
| updatedAt | datetime | Дата и время последнего обновления этапа. |

---

## Таблица 10 – Структура таблицы StageComment

Таблица StageComment содержит комментарии к этапам ремонта. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор комментария. |
| stageId | uuid | Идентификатор этапа, к которому относится комментарий. |
| authorId | uuid | Идентификатор автора комментария. |
| content | nvarchar(4000) | Текст комментария. |
| createdAt | datetime | Дата и время создания комментария. |
| updatedAt | datetime | Дата и время последнего обновления комментария. |

---

## Таблица 11 – Структура таблицы StageAttachment

Таблица StageAttachment содержит файлы и фотографии, прикрепленные к этапам ремонта. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор вложения. |
| stageId | uuid | Идентификатор этапа, к которому прикреплен файл. |
| uploadedById | uuid | Идентификатор пользователя, загрузившего файл. |
| fileName | varchar | Имя файла. |
| filePath | varchar | Путь к файлу на сервере. |
| fileSize | int | Размер файла в байтах. |
| mimeType | varchar | MIME-тип файла (необязательно). |
| description | varchar | Описание файла (необязательно). |
| createdAt | datetime | Дата и время загрузки файла. |

---

## Таблица 12 – Структура таблицы InventoryItem

Таблица InventoryItem содержит информацию о комплектующих и расходных материалах на складе. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор комплектующего. |
| name | varchar | Название комплектующего. |
| description | varchar | Описание комплектующего (необязательно). |
| category | varchar | Категория: «engine», «transmission», «oil», «filter», «brakes» и т.д. |
| subcategory | varchar | Подкатегория для детализации (необязательно). |
| sku | varchar | SKU артикул (необязательно, уникальный). |
| oemNumber | varchar | OEM-номер производителя (необязательно). |
| manufacturerPartNumber | varchar | Артикул производителя (необязательно). |
| manufacturer | varchar | Производитель детали (необязательно). |
| stock | int | Количество на складе. По умолчанию 0. |
| minStock | int | Минимальный остаток для уведомлений. По умолчанию 0. |
| unit | varchar | Единица измерения. По умолчанию «шт». |
| price | decimal(10,2) | Цена продажи (необязательно). |
| cost | decimal(10,2) | Себестоимость (необязательно). |
| isUniversal | boolean | Универсальная деталь (подходит для всех автомобилей). По умолчанию false. |
| isActive | boolean | Статус активности позиции. По умолчанию true. |
| weight | decimal(10,3) | Вес в килограммах (необязательно). |
| location | varchar | Место на складе (стеллаж/полка) (необязательно). |
| notes | nvarchar(2000) | Дополнительные примечания (необязательно). |
| createdAt | datetime | Дата и время создания записи. |
| updatedAt | datetime | Дата и время последнего обновления записи. |

---

## Таблица 13 – Структура таблицы InventoryItemCompatibility

Таблица InventoryItemCompatibility содержит информацию о совместимости комплектующих с конкретными моделями автомобилей. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор записи о совместимости. |
| inventoryItemId | uuid | Идентификатор комплектующего. |
| vehicleBrandId | uuid | Идентификатор марки автомобиля. Если null – подходит для всех марок. |
| vehicleModelId | uuid | Идентификатор модели автомобиля. Если null – подходит для всех моделей бренда. |
| vehicleGenerationId | uuid | Идентификатор поколения автомобиля. Если null – подходит для всех поколений модели. |
| yearFrom | int | Год начала совместимости (необязательно). |
| yearTo | int | Год окончания совместимости (необязательно). |
| notes | varchar | Примечания о совместимости (необязательно). |
| createdAt | datetime | Дата и время создания записи. |

Продолжение таблицы 13

| Название | Тип данных | Описание |
|----------|-----------|----------|

---

## Таблица 14 – Структура таблицы InventoryItemCrossReference

Таблица InventoryItemCrossReference содержит кросс-ссылки на аналоги и замены комплектующих. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор кросс-ссылки. |
| fromItemId | uuid | Идентификатор исходного комплектующего. |
| toItemId | uuid | Идентификатор аналога или замены. |
| referenceType | varchar | Тип ссылки: «replacement» (замена), «analog» (аналог), «upgrade» (улучшение), «downgrade» (понижение). |
| notes | varchar | Примечания (необязательно). |
| createdAt | datetime | Дата и время создания записи. |

---

## Таблица 15 – Структура таблицы StageTemplateInventoryItem

Таблица StageTemplateInventoryItem содержит рекомендуемые комплектующие для шаблонов этапов. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор записи. |
| stageTemplateId | uuid | Идентификатор шаблона этапа. |
| inventoryItemId | uuid | Идентификатор комплектующего. |
| isRequired | boolean | Обязательное или опциональное комплектующее. По умолчанию false. |
| quantity | int | Рекомендуемое количество. По умолчанию 1. |
| notes | varchar | Примечания для администратора (необязательно). |
| createdAt | datetime | Дата и время создания записи. |

---

## Таблица 16 – Структура таблицы OrderStageInventoryItem

Таблица OrderStageInventoryItem содержит комплектующие, предложенные администратором и выбранные клиентом для конкретного этапа заказа. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор записи. |
| orderStageId | uuid | Идентификатор этапа заказа. |
| inventoryItemId | uuid | Идентификатор комплектующего. |
| quantity | int | Количество. По умолчанию 1. |
| unitPrice | decimal(10,2) | Цена за единицу (необязательно). |
| isRequired | boolean | Обязательное или опциональное комплектующее. По умолчанию false. |
| suggestedByAdmin | boolean | Предложено администратором. По умолчанию true. |
| selectedByClient | boolean | Выбрано клиентом. По умолчанию false. |
| status | varchar | Статус: «pending» (ожидает решения), «approved» (одобрено), «rejected» (отклонено), «installed» (установлено). По умолчанию «pending». |
| clientNotes | varchar | Комментарий клиента (необязательно). |
| adminNotes | varchar | Комментарий администратора (необязательно). |
| createdAt | datetime | Дата и время создания записи. |
| updatedAt | datetime | Дата и время последнего обновления записи. |

---

## Таблица 17 – Структура таблицы OrderInventoryItem

Таблица OrderInventoryItem содержит общие комплектующие заказа (для обратной совместимости). Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор записи. |
| orderId | uuid | Идентификатор заказа. |
| inventoryItemId | uuid | Идентификатор комплектующего. |
| quantity | int | Количество. По умолчанию 1. |
| unitPrice | decimal(10,2) | Цена за единицу (необязательно). |
| createdAt | datetime | Дата и время создания записи. |

---

## Таблица 18 – Структура таблицы Notification

Таблица Notification содержит уведомления пользователей о событиях в системе. Описание полей приведено ниже.

| Название | Тип данных | Описание |
|----------|-----------|----------|
| id | uuid | Уникальный идентификатор уведомления. |
| userId | uuid | Идентификатор пользователя, которому предназначено уведомление. |
| type | varchar | Тип уведомления: «new_order», «stage_done», «stage_assigned», «inventory_suggested» и т.д. |
| channel | varchar | Канал уведомления: «in_app» (в приложении), «email» и т.д. По умолчанию «in_app». |
| title | varchar | Заголовок уведомления. |
| message | nvarchar(2000) | Текст уведомления. |
| isRead | boolean | Прочитано ли уведомление. По умолчанию false. |
| readAt | datetime | Дата и время прочтения уведомления (необязательно). |
| metadata | nvarchar(4000) | Дополнительные метаданные в формате JSON (необязательно). |
| createdAt | datetime | Дата и время создания уведомления. |
| orderId | uuid | Идентификатор связанного заказа (необязательно). |

---

## Таблица 19 – Назначение связей между таблицами

| Таблица источник | Связанная таблица | Тип связи |
|------------------|-------------------|-----------|
| User | Order | Один ко многим |
| User | OrderStage | Один ко многим |
| User | StageComment | Один ко многим |
| User | StageAttachment | Один ко многим |
| User | Notification | Один ко многим |
| VehicleBrand | VehicleModel | Один ко многим |
| VehicleBrand | InventoryItemCompatibility | Один ко многим |
| VehicleModel | VehicleGeneration | Один ко многим |
| VehicleModel | InventoryItemCompatibility | Один ко многим |
| VehicleGeneration | Order | Один ко многим |
| VehicleGeneration | InventoryItemCompatibility | Один ко многим |
| ServiceTemplate | StageTemplate | Один ко многим |
| ServiceTemplate | Order | Один ко многим |
| StageTemplate | OrderStage | Один ко многим |
| StageTemplate | StageTemplateInventoryItem | Один ко многим |
| Order | OrderStage | Один ко многим |
| Order | OrderInventoryItem | Один ко многим |
| Order | Notification | Один ко многим |
| OrderStage | StageComment | Один ко многим |
| OrderStage | StageAttachment | Один ко многим |
| OrderStage | OrderStageInventoryItem | Один ко многим |
| InventoryItem | InventoryItemCompatibility | Один ко многим |
| InventoryItem | InventoryItemCrossReference (fromItem) | Один ко многим |
| InventoryItem | InventoryItemCrossReference (toItem) | Один ко многим |
| InventoryItem | StageTemplateInventoryItem | Один ко многим |
| InventoryItem | OrderStageInventoryItem | Один ко многим |
| InventoryItem | OrderInventoryItem | Один ко многим |

---

## 2.3 Архитектура web-приложения

Приложение разработано на основе клиент-серверной архитектуры, что обеспечивает четкое разделение логики и способствует масштабируемости системы.

Клиентская часть (frontend) реализована с использованием библиотеки React, обеспечивающей компонентный подход к построению пользовательского интерфейса. Для сборки и оптимизации клиентского приложения используется инструмент Vite, обеспечивающий быструю разработку и эффективную сборку production-версии. Стилизация компонентов выполнена с помощью CSS-фреймворка Tailwind CSS, позволяющего создавать адаптивный интерфейс с использованием утилитарных классов. Маршрутизация между страницами реализована с помощью библиотеки React Router, обеспечивающей навигацию в одностраничном приложении (SPA).

Обмен данными между клиентом и сервером осуществляется с помощью библиотеки Axios посредством HTTP-запросов к RESTful API. Для эффективного управления серверным состоянием и кэширования данных используется библиотека TanStack Query (React Query), обеспечивающая автоматическое обновление данных и оптимистичные обновления интерфейса. Локальное состояние приложения, включая данные аутентификации, управляется с помощью легковесной библиотеки Zustand, обеспечивающей централизованное хранение состояния с поддержкой персистентности в localStorage.

Серверная часть (backend) реализована на платформе Node.js с использованием фреймворка Express, что позволило эффективно организовать маршрутизацию и обработку API-запросов. Серверная логика организована по модульному принципу, где каждый модуль (auth, orders, stages, inventory, notifications и др.) содержит собственный роутер и сервисный слой. Для работы с базой данных применяется ORM Prisma, обеспечивающая типобезопасное взаимодействие с реляционной СУБД и автоматическую генерацию TypeScript-типов на основе схемы базы данных.

Аутентификация пользователей реализована с использованием JWT-токенов (JSON Web Tokens) через библиотеку jsonwebtoken. Access-токен передается в заголовке Authorization каждого защищенного запроса, а refresh-токен используется для обновления сессии. Для хеширования паролей применяется библиотека bcryptjs. Безопасность приложения усилена с помощью middleware Helmet, устанавливающего защитные HTTP-заголовки, и настроенной политики CORS для контроля межсайтовых запросов.

В качестве системы управления базами данных используется Microsoft SQL Server, предназначенная для хранения информации о пользователях, заказах, этапах ремонта, каталоге автомобилей, складских запасах комплектующих и уведомлениях. Обработка операций чтения, записи, обновления и удаления данных реализована с использованием Prisma-моделей с поддержкой транзакций и каскадного удаления.

Для хранения и обработки мультимедийных файлов (фотографий этапов ремонта, документов) используется локальное файловое хранилище на сервере. Загрузка файлов осуществляется посредством передачи данных в формате Base64 через API, после чего файлы сохраняются в директорию uploads с генерацией уникальных имен для предотвращения коллизий. Клиент получает относительный путь к файлу для последующего отображения.

Система уведомлений реализована на основе модели «pull» – клиентское приложение периодически запрашивает новые уведомления через REST API. Уведомления хранятся в базе данных и включают информацию о типе события, связанном заказе и статусе прочтения.

Архитектура приложения представлена в Приложении В.

Таким образом, клиент-серверное взаимодействие осуществляется по следующей схеме: клиент инициирует запрос через Axios с JWT-токеном в заголовке, сервер проверяет аутентификацию через middleware, обрабатывает бизнес-логику в сервисном слое, взаимодействует с базой данных через Prisma и, при необходимости, с файловым хранилищем, формирует JSON-ответ и возвращает его на клиентскую сторону для дальнейшего отображения и кэширования в React Query.

---

## 2.4 Выводы по разделу

В рамках раздела была рассмотрена функциональность web-приложения, предназначенная для всех ролей: гостя, клиента, механика и администратора. Рассмотрена логическая схема базы данных web-приложения, которая включает 17 таблиц. В таблицах хранятся данные о пользователях, заказах на ремонт, этапах выполнения работ, каталоге автомобилей, складских запасах комплектующих, уведомлениях и другое. Также рассмотрена архитектура приложения, построенная на основе клиент-серверной модели с использованием современного стека технологий: React, TypeScript, Node.js, Express, Prisma и Microsoft SQL Server.

---

# 3 Реализация web-приложения

## 3.1 Программная платформа Node.js

Для серверной части проекта была использована платформа Node.js с использованием фреймворка Express, которая обеспечивает высокую производительность и гибкость при разработке web-приложений.

В рамках проекта Express используется для создания RESTful API, что позволяет эффективно реализовывать взаимодействие между клиентской и серверной частью приложения. API организовано по модульному принципу с разделением на функциональные модули: auth (аутентификация), orders (заказы), stages (этапы ремонта), inventory (склад), notifications (уведомления), vehicles (каталог автомобилей) и admin (административные функции).

Express предоставляет удобные механизмы для маршрутизации, валидации запросов и подключения middleware-компонентов, что значительно упрощает разработку и настройку серверной части. В проекте используются следующие middleware: Helmet для установки защитных HTTP-заголовков, CORS для настройки политики межсайтовых запросов, Morgan для логирования HTTP-запросов, cookie-parser для работы с cookies и express-session для управления сессиями.

Благодаря поддержке модульной структуры и интеграции с ORM Prisma, платформа позволяет упростить работу с базой данных, обеспечить масштабируемость приложения и ускорить процесс разработки серверной логики. Для валидации входных данных используется библиотека Zod, обеспечивающая типобезопасную валидацию на уровне runtime.

## 3.2 Система управления базами данных Microsoft SQL Server

Для работы web-приложения используется Microsoft SQL Server – мощная, надёжная и масштабируемая система управления базами данных корпоративного уровня. SQL Server поддерживает сложные SQL-запросы, транзакции, хранимые процедуры, а также работу с расширенными типами данных, включая NVARCHAR для хранения Unicode-текста. Такая СУБД идеально подходит для корпоративного web-приложения автосервиса, обеспечивая высокую производительность, целостность данных и устойчивость к нагрузкам.

## 3.3 Реализация базы данных

Для реализации базы данных в проекте применяется подход Schema First с использованием ORM-библиотеки Prisma. Это позволяет сначала определить структуру данных в виде схемы на языке Prisma Schema Language (PSL), а затем автоматически сгенерировать типобезопасный клиент для работы с базой данных и применить миграции для синхронизации схемы с базой данных.

Код подключения к базе данных приведён в листинге 3.1.

```typescript
import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      process.env.NODE_ENV === "development"
        ? ["query", "error", "warn"]
        : ["error"],
  });

if (process.env.NODE_ENV !== "production") {
  globalForPrisma.prisma = prisma;
}

process.on("beforeExit", async () => {
  await prisma.$disconnect();
});
```

Листинг 3.1 – Код подключения к базе данных

Конфигурация подключения к базе данных вынесена в отдельный модуль конфигурации, где параметры подключения загружаются из файла окружения .env с помощью библиотеки dotenv и валидируются с использованием библиотеки Zod. Код конфигурации окружения приведён в листинге 3.2.

```typescript
import { config } from "dotenv";
import { z } from "zod";
import { resolve } from "path";

config({ path: resolve(process.cwd(), ".env") });

const schema = z.object({
  NODE_ENV: z.enum(["development", "test", "production"]).default("development"),
  PORT: z.coerce.number().positive().default(3001),
  CORS_ORIGIN: z.string().default("*"),
  DATABASE_URL: z.string().min(1, "DATABASE_URL is required"),
  JWT_SECRET: z.string().min(32, "JWT_SECRET must be at least 32 characters"),
  JWT_EXPIRES_IN: z.string().default("7d"),
  SESSION_SECRET: z.string().min(32, "SESSION_SECRET must be at least 32 characters"),
});

export type Env = z.infer<typeof schema>;
export const env: Env = schema.parse(process.env);
```

Листинг 3.2 – Код конфигурации окружения

Модели базы данных описываются в файле schema.prisma. Каждая модель соответствует таблице и определяет поля, типы данных, связи (например, «один ко многим») и ограничения. Примеры моделей: User, Order, OrderStage, InventoryItem, VehicleBrand, VehicleModel, VehicleGeneration, Notification и другие.

Связи между моделями определяются с помощью директив @relation, которые указывают на внешние ключи и тип связи. Prisma автоматически генерирует TypeScript-типы на основе схемы, что обеспечивает типобезопасность при работе с данными во всём приложении.

Инициализация подключения к базе данных и запуск сервера вынесены в отдельный модуль main.ts. Процесс запуска включает проверку подключения к базе данных, запуск HTTP-сервера и настройку обработчиков graceful shutdown для корректного завершения работы. Код запуска сервера приведён в листинге 3.3.

```typescript
import { buildApp } from "./app.js";
import { env } from "./config/env.js";
import { prisma } from "./db/prisma.js";

const app = buildApp();

async function startServer() {
  try {
    console.log("Подключение к базе данных...");
    await prisma.$connect();
    console.log("Подключение к базе данных установлено");

    const server = app.listen(env.PORT, () => {
      console.log(`API listening on http://localhost:${env.PORT}`);
    });

    const shutdown = async () => {
      console.log("Shutting down server...");
      await prisma.$disconnect();
      server.close(() => {
        console.log("Server stopped");
        process.exit(0);
      });
    };

    process.on("SIGINT", shutdown);
    process.on("SIGTERM", shutdown);
  } catch (error) {
    console.error("Ошибка подключения к базе данных:", error);
    process.exit(1);
  }
}

startServer();
```

Листинг 3.3 – Код запуска сервера

Для применения изменений схемы к базе данных используется механизм миграций Prisma. Команда `prisma migrate dev` создаёт SQL-миграцию на основе изменений в schema.prisma и применяет её к базе данных. Команда `prisma generate` генерирует типобезопасный клиент Prisma на основе текущей схемы.

Этот механизм особенно удобен при использовании подхода Schema First, так как позволяет контролировать изменения схемы базы данных через систему контроля версий и обеспечивает воспроизводимость развёртывания. После завершения миграций база данных готова к использованию, и запускается сервер приложения. Кроме того, централизованное описание моделей в schema.prisma упрощает внесение изменений в структуру базы данных, обеспечивая согласованность всех зависимостей и связей между таблицами.

## 3.4 Программные библиотеки


Таблица 3.1 – Программные библиотеки серверной части

| Библиотека | Версия | Назначение |
|------------|--------|------------|
| Express | 4.21.2 | Фреймворк для создания HTTP-сервера и маршрутизации. |
| @prisma/client | 5.20.0 | ORM-библиотека для типобезопасного взаимодействия с базой данных Microsoft SQL Server. |
| Prisma | 5.20.0 | CLI-инструмент для управления схемой базы данных и миграциями. |
| Jsonwebtoken | 9.0.2 | Библиотека для генерации и валидации JWT-токенов (аутентификация). |
| Bcryptjs | 2.4.3 | Хеширование паролей пользователей. |
| Zod | 3.23.8 | Типобезопасная валидация данных на уровне runtime. |
| Helmet | 7.1.0 | Установка защитных HTTP-заголовков для повышения безопасности. |
| Cors | 2.8.5 | Обеспечение поддержки CORS для работы с клиентской частью. |
| Morgan | 1.10.0 | Логирование HTTP-запросов в консоль. |
| Cookie-parser | 1.4.6 | Парсинг cookies из HTTP-запросов. |
| Express-session | 1.18.1 | Управление сессиями пользователей. |
| Dotenv | 16.4.5 | Загрузка конфигурации из .env-файла. |
| TypeScript | 5.4.5 | Статическая типизация JavaScript-кода. |
| Tsx | 4.19.0 | Выполнение TypeScript-файлов без предварительной компиляции. |

В процессе разработки клиентской части web-приложения были задействованы программные библиотеки, представленные в таблице 3.2.

Таблица 3.2 – Программные библиотеки клиентской части

| Библиотека | Версия | Назначение |
|------------|--------|------------|
| React | 18.3.1 | Основная библиотека для построения пользовательского интерфейса. |
| React-dom | 18.3.1 | Рендеринг React-компонентов в DOM браузера. |
| React-router-dom | 6.26.1 | Реализация маршрутизации в одностраничном приложении (SPA). |
| Axios | 1.7.2 | Отправка HTTP-запросов к серверу. |
| @tanstack/react-query | 5.50.1 | Управление серверным состоянием, кэширование и синхронизация данных. |
| Zustand | 4.5.2 | Легковесная библиотека для управления глобальным состоянием приложения. |
| Clsx | 2.1.1 | Утилита для условного объединения CSS-классов. |
| Tailwind CSS | 3.4.4 | CSS-фреймворк с утилитарными классами для стилизации интерфейса. |
| Vite | 5.2.13 | Инструмент сборки и dev-сервер для быстрой разработки. |
| TypeScript | 5.4.5 | Статическая типизация JavaScript-кода. |
| PostCSS | 8.4.39 | Инструмент для трансформации CSS с помощью плагинов. |
| Autoprefixer | 10.4.19 | Автоматическое добавление вендорных префиксов в CSS. |

Эти библиотеки обеспечивают устойчивую архитектуру REST API, безопасность при работе с данными и простоту поддержки проекта.

Использование перечисленных библиотек позволяет сформировать отзывчивый и функциональный пользовательский интерфейс, реализовать навигацию по страницам и обеспечить стабильное взаимодействие с серверной частью приложения.

## 3.5 Структура серверной части

Структура серверной части приложения, реализованная на платформе Node.js с использованием фреймворка Express, включает в себя основные компоненты, необходимые для обработки HTTP-запросов, маршрутизации, работы с базой данных и обеспечения расширяемости архитектуры.

Для обеспечения удобной навигации и поддержки расширяемости серверной части проекта каждая директория имеет чётко определённое назначение. В таблице 3.3 приведён список директорий проекта разработки web-приложения и назначение файлов, хранящихся в этих директориях.

Таблица 3.3 – Директории серверной части проекта

| Директория | Назначение |
|------------|------------|
| config | Содержит конфигурационные файлы приложения, включая настройки окружения и валидацию переменных среды с помощью Zod. |
| db | Содержит модуль подключения к базе данных через Prisma Client с реализацией singleton-паттерна. |
| middleware | Содержит промежуточные обработчики для аутентификации JWT-токенов, проверки ролей пользователей и других задач. |
| modules | Содержит функциональные модули приложения, каждый из которых включает роутер и сервис для обработки бизнес-логики. |
| routes | Определяет централизованную регистрацию всех маршрутов API и связывает их с соответствующими модулями. |
| utils | Содержит вспомогательные функции, включая утилиты для сохранения загружаемых файлов. |
| scripts | Содержит скрипты для начального заполнения базы данных тестовыми данными (seeding). |
| store | Содержит модули для работы с временным хранилищем данных в памяти. |

На основе диаграммы вариантов использования были определены основные маршруты серверной части, соответствующие ключевым действиям пользователей. Серверная часть организована по модульному принципу, где каждый модуль содержит роутер (router) для определения маршрутов и сервис (service) для реализации бизнес-логики. Роутер обрабатывает HTTP-запросы, проводит валидацию данных с помощью библиотеки Zod, вызывает методы сервиса и возвращает ответы в формате JSON.

Такой подход обеспечивает чёткое разделение ответственности между уровнями приложения и упрощает сопровождение серверной логики. Таблица 3.4 содержит соответствие маршрутов, HTTP-методов и функций модуля auth, который реализует операции аутентификации и управления учётными записями пользователей.

Таблица 3.4 – Маршруты модуля аутентификации (auth)

| Метод | Маршрут | Функция | Описание |
|-------|---------|---------|----------|
| POST | /api/auth/register | registerUser | Регистрация нового пользователя |
| POST | /api/auth/login | loginUser | Вход в систему |
| POST | /api/auth/logout | logout | Выход из системы |
| GET | /api/auth/me | getUserById | Получение данных текущего пользователя |
| POST | /api/auth/refresh | refreshToken | Обновление access-токена |
| PATCH | /api/auth/profile | updateUserProfile | Обновление профиля пользователя |
| POST | /api/auth/change-password | changeUserPassword | Смена пароля |
| DELETE | /api/auth/account | deleteUserAccount | Удаление аккаунта |

Модуль orders отвечает за управление заказами клиентов. Он реализует маршруты для создания, получения и управления заказами на ремонт автомобилей. В таблице 3.5 представлено соответствие маршрутов и функций данного модуля.

Таблица 3.5 – Маршруты модуля заказов (orders)

| Метод | Маршрут | Функция | Описание |
|-------|---------|---------|----------|
| GET | /api/orders | getOrdersByCustomer | Получение заказов текущего пользователя |
| GET | /api/orders/:id | getOrderById | Получение заказа по идентификатору |
| POST | /api/orders | createOrder | Создание нового заказа |

Модуль stages отвечает за управление этапами выполнения заказов. Он предоставляет функционал для механиков по обновлению статусов этапов, добавлению комментариев и загрузке файлов. В таблице 3.6 представлено соответствие маршрутов и функций данного модуля.

Таблица 3.6 – Маршруты модуля этапов (stages)

| Метод | Маршрут | Функция | Описание |
|-------|---------|---------|----------|
| GET | /api/stages/order/:orderId | getOrderStages | Получение этапов заказа |
| GET | /api/stages/assigned | getAssignedOrders | Получение назначенных заказов (для механика) |
| GET | /api/stages/:stageId | getStageById | Получение этапа с деталями |
| PATCH | /api/stages/:stageId | updateStageStatus | Обновление статуса этапа |
| POST | /api/stages/:stageId/comments | addComment | Добавление комментария к этапу |
| POST | /api/stages/:stageId/attachments | addAttachment | Добавление вложения к этапу |
| POST | /api/stages/:stageId/view | markStageViewed | Отметка этапа как просмотренного |
| GET | /api/stages/:stageId/inventory | getStageInventory | Получение комплектующих этапа |
| PATCH | /api/stages/inventory/:itemId/respond | respondToInventory | Ответ клиента на предложение комплектующего |

Модуль admin предоставляет функционал администрирования системы, включая управление заказами, этапами, шаблонами услуг и комплектующими. В таблице 3.7 представлены основные маршруты административного модуля.

Таблица 3.7 – Маршруты модуля администрирования (admin)

| Метод | Маршрут | Функция | Описание |
|-------|---------|---------|----------|
| GET | /api/admin/orders | getOrdersOverview | Получение списка всех заказов |
| POST | /api/admin/orders/:orderId/view | markOrderViewed | Отметка заказа как просмотренного |
| GET | /api/admin/mechanics | getMechanics | Получение списка механиков |
| POST | /api/admin/orders/:orderId/stages | createOrderStage | Создание этапа заказа |
| PATCH | /api/admin/orders/:orderId/stages/:stageId | updateOrderStage | Обновление этапа заказа |
| DELETE | /api/admin/orders/:orderId/stages/:stageId | deleteOrderStage | Удаление этапа заказа |
| POST | /api/admin/orders/:orderId/stages/reorder | reorderOrderStages | Изменение порядка этапов |
| POST | /api/admin/service-templates | createServiceTemplate | Создание шаблона услуги |
| PATCH | /api/admin/service-templates/:id | updateServiceTemplate | Обновление шаблона услуги |
| DELETE | /api/admin/service-templates/:id | deleteServiceTemplate | Удаление шаблона услуги |
| POST | /api/admin/stage-templates | createStageTemplate | Создание шаблона этапа |
| PATCH | /api/admin/stage-templates/:id | updateStageTemplate | Обновление шаблона этапа |
| DELETE | /api/admin/stage-templates/:id | deleteStageTemplate | Удаление шаблона этапа |
| POST | /api/admin/order-stages/:stageId/inventory | suggestInventoryForOrderStage | Предложение комплектующего для этапа |
| GET | /api/admin/order-stages/:stageId/inventory | getOrderStageInventoryItems | Получение комплектующих этапа |
| PATCH | /api/admin/order-stage-inventory/:id | updateOrderStageInventoryItem | Обновление комплектующего этапа |
| DELETE | /api/admin/order-stage-inventory/:id | removeInventoryFromOrderStage | Удаление комплектующего из этапа |

Модуль warehouse предоставляет функционал управления складом комплектующих, включая CRUD-операции и управление совместимостью деталей с моделями автомобилей. В таблице 3.8 представлены маршруты модуля склада.

Таблица 3.8 – Маршруты модуля склада (warehouse)

| Метод | Маршрут | Функция | Описание |
|-------|---------|---------|----------|
| GET | /api/warehouse | getInventoryItems | Получение списка комплектующих с фильтрацией |
| GET | /api/warehouse/compatible | getCompatibleInventoryItems | Получение совместимых комплектующих для автомобиля |
| GET | /api/warehouse/:id | getInventoryItemById | Получение комплектующего по идентификатору |
| POST | /api/warehouse | createInventoryItem | Создание комплектующего |
| PATCH | /api/warehouse/:id | updateInventoryItem | Обновление комплектующего |
| DELETE | /api/warehouse/:id | deleteInventoryItem | Удаление комплектующего |
| POST | /api/warehouse/compatibility | addCompatibility | Добавление совместимости с автомобилем |
| DELETE | /api/warehouse/compatibility/:id | removeCompatibility | Удаление совместимости |
| POST | /api/warehouse/cross-reference | addCrossReference | Добавление кросс-ссылки на аналог |
| DELETE | /api/warehouse/cross-reference/:id | removeCrossReference | Удаление кросс-ссылки |

Модуль vehicles предоставляет публичный API для работы с каталогом автомобилей. В таблице 3.9 представлены маршруты модуля.

Таблица 3.9 – Маршруты модуля автомобилей (vehicles)

| Метод | Маршрут | Функция | Описание |
|-------|---------|---------|----------|
| GET | /api/vehicles/brands | getBrands | Получение списка марок автомобилей |
| GET | /api/vehicles/brands/:brandId/models | getModelsByBrand | Получение моделей по марке |
| GET | /api/vehicles/models/:modelId/generations | getGenerationsByModel | Получение поколений по модели |
| GET | /api/vehicles/generations/:generationId | getGenerationById | Получение поколения по идентификатору |

Модуль notifications обеспечивает работу с системой уведомлений пользователей. В таблице 3.10 представлены маршруты модуля.

Таблица 3.10 – Маршруты модуля уведомлений (notifications)

| Метод | Маршрут | Функция | Описание |
|-------|---------|---------|----------|
| GET | /api/notifications | getUserFeed | Получение уведомлений пользователя |
| POST | /api/notifications/:id/read | markAsRead | Отметка уведомления как прочитанного |
| POST | /api/notifications/read-all | markAllAsRead | Отметка всех уведомлений как прочитанных |

Модули catalog и progress предоставляют дополнительный функционал для работы с каталогом услуг и отслеживания прогресса выполнения заказов. В таблице 3.11 представлены маршруты этих модулей.

Таблица 3.11 – Маршруты модулей каталога и прогресса

| Метод | Маршрут | Функция | Описание |
|-------|---------|---------|----------|
| GET | /api/catalog/services | getServiceTemplates | Получение шаблонов услуг |
| GET | /api/catalog/services/:id | getServiceTemplateById | Получение шаблона услуги по идентификатору |
| GET | /api/catalog/inventory | getInventoryItems | Получение комплектующих из каталога |
| GET | /api/catalog/inventory/:id | getInventoryItemById | Получение комплектующего по идентификатору |
| GET | /api/progress/:orderId/timeline | getOrderStages | Получение временной шкалы заказа |
| POST | /api/progress/:orderId/stages/:stageId | updateStageStatus | Обновление статуса этапа |

Модуль inventory обеспечивает работу с комплектующими в контексте заказов. В таблице 3.12 представлены маршруты модуля.

Таблица 3.12 – Маршруты модуля комплектующих заказа (inventory)

| Метод | Маршрут | Функция | Описание |
|-------|---------|---------|----------|
| POST | /api/inventory/orders/:orderId/items | addItemToOrder | Добавление комплектующего в заказ |
| GET | /api/inventory/orders/:orderId/items | getOrderItems | Получение комплектующих заказа |
| PATCH | /api/inventory/orders/:orderId/items/:itemId | updateItemQuantity | Обновление количества комплектующего |
| DELETE | /api/inventory/orders/:orderId/items/:itemId | removeItemFromOrder | Удаление комплектующего из заказа |

При передаче данных между клиентом и сервером используется формат JSON (JavaScript Object Notation). В роутерах осуществляется взаимодействие с сервисами, которые инкапсулируют бизнес-логику приложения и обеспечивают работу с базой данных через Prisma ORM.

## 3.6 Реализация функций пользователя с ролью «гость»

### 3.6.1 Регистрация

Для гостя web-приложения доступна возможность регистрации. Данная функция позволяет пользователю создать учётную запись в системе и получить доступ к функционалу, требующему авторизации. Процесс регистрации реализован в функции registerUser сервиса auth.service. Реализация данной функции приведена в листинге 3.13.

```typescript
export async function registerUser(
  email: string,
  password: string,
  fullName: string,
  phone?: string,
): Promise<AuthUser> {
  const existing = await prisma.user.findUnique({
    where: { email },
  });

  if (existing) {
    throw new Error("Пользователь с таким email уже существует");
  }

  const passwordHash = await hashPassword(password);

  const user = await prisma.user.create({
    data: {
      email,
      passwordHash,
      fullName,
      phone,
      role: "client",
    },
  });

  return {
    id: user.id,
    email: user.email,
    fullName: user.fullName,
    role: user.role as UserRole,
    phone: user.phone,
  };
}
```

Листинг 3.13 – Реализация функции registerUser

Перед выполнением основной логики регистрации HTTP-запрос проходит через валидацию с использованием библиотеки Zod, которая проверяет входные данные на соответствие установленным требованиям: формат электронной почты, минимальная длина пароля (6 символов), наличие полного имени (минимум 2 символа) и опциональный номер телефона. Схема валидации определена в роутере и представлена в листинге 3.14.

```typescript
const registerSchema = z.object({
  email: z.string().email("Некорректный email"),
  password: z.string().min(6, "Пароль должен содержать минимум 6 символов"),
  fullName: z.string().min(2, "Имя должно содержать минимум 2 символа"),
  phone: z.string().optional(),
});
```

Листинг 3.14 – Схема валидации регистрации

В случае успешного прохождения проверки управление передаётся функции registerUser. Функция выполняет проверку на наличие пользователя с указанным адресом электронной почты через Prisma ORM. Если пользователь уже существует, возвращается соответствующее сообщение об ошибке со статусом 409 (Conflict). В противном случае осуществляется хеширование пароля с использованием библиотеки bcryptjs с солью из 10 раундов, создаётся новая запись в базе данных, содержащая информацию о пользователе. После регистрации пользователю автоматически назначается роль «client» (клиент).

### 3.6.2 Аутентификация

Гость web-приложения имеет возможность пройти процедуру аутентификации, получив тем самым права на выполнение действий, соответствующих определённой роли в системе. Процесс аутентификации реализован в функции loginUser сервиса auth.service. Реализация данной функции представлена в листинге 3.15.

```typescript
export async function loginUser(
  email: string,
  password: string,
): Promise<{ user: AuthUser; tokens: AuthTokens }> {
  const user = await prisma.user.findUnique({
    where: { email },
  });

  if (!user || !user.isActive) {
    throw new Error("Неверный email или пароль");
  }

  const isValid = await verifyPassword(password, user.passwordHash);
  if (!isValid) {
    throw new Error("Неверный email или пароль");
  }

  const authUser: AuthUser = {
    id: user.id,
    email: user.email,
    fullName: user.fullName,
    role: user.role as UserRole,
    phone: user.phone,
  };

  const tokens: AuthTokens = {
    accessToken: generateAccessToken(authUser),
    refreshToken: generateRefreshToken(user.id),
  };

  return { user: authUser, tokens };
}
```

Листинг 3.15 – Реализация функции loginUser

Перед выполнением основной логики аутентификации данные, передаваемые в теле HTTP-запроса, проходят предварительную валидацию с помощью Zod-схемы loginSchema, которая проверяет корректность формата email и наличие пароля.

Далее осуществляется идентификация пользователя в системе: происходит поиск по адресу электронной почты, указанному в запросе, через Prisma ORM. Если пользователь найден и его аккаунт активен (isActive = true), хеш пароля, хранящийся в базе данных, сравнивается с паролем, переданным в запросе, с использованием функции bcrypt.compare. В случае совпадения генерируются два JWT-токена: access-токен (срок действия 7 дней) и refresh-токен (срок действия 30 дней). Токены содержат идентификатор, email и роль пользователя.

Сформированные токены устанавливаются в httpOnly cookies для защиты от XSS-атак и также возвращаются в теле ответа. Это позволяет использовать токены как из cookies (для браузерных запросов), так и из заголовка Authorization (для API-запросов).

В дальнейшем, при попытке выполнения операций, требующих авторизации, все запросы проходят через middleware authenticateToken, реализация которого представлена в листинге 3.16.

```typescript
export async function authenticateToken(
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader?.startsWith("Bearer ")
      ? authHeader.substring(7)
      : req.cookies?.accessToken;

    if (!token) {
      res.status(401).json({ message: "Токен доступа не предоставлен" });
      return;
    }

    const decoded = verifyToken(token);
    if (!decoded) {
      res.status(401).json({ message: "Недействительный токен" });
      return;
    }

    const user = await getUserById(decoded.id);
    if (!user) {
      res.status(401).json({ message: "Пользователь не найден или неактивен" });
      return;
    }

    req.user = {
      id: decoded.id,
      email: decoded.email,
      role: decoded.role,
    };

    next();
  } catch (error) {
    res.status(401).json({ message: "Ошибка аутентификации" });
  }
}
```

Листинг 3.16 – Реализация middleware authenticateToken

Middleware извлекает токен из заголовка Authorization (формат Bearer) или из cookies, проверяет его валидность через функцию verifyToken, а также проверяет существование и активность пользователя в базе данных. При успешной проверке в объект запроса добавляется информация о пользователе (id, email, role), что позволяет роутерам выполнять действия от имени конкретного пользователя и проверять его права доступа.

### 3.6.3 Просмотр информации об услугах автосервиса

Неавторизованные пользователи (гости) имеют возможность просматривать информацию о доступных услугах автосервиса на главной странице приложения. Для получения списка услуг используется публичный API-эндпоинт, не требующий авторизации. Функция получения шаблонов услуг представлена в листинге 3.17.

```typescript
async getServiceTemplates() {
  return prisma.serviceTemplate.findMany({
    where: { isActive: true },
    include: {
      stageTemplates: {
        orderBy: { orderIndex: "asc" },
      },
    },
    orderBy: { name: "asc" },
  });
}
```

Листинг 3.17 – Реализация функции getServiceTemplates

Функция возвращает список всех активных услуг из базы данных, включая связанные с ними шаблоны этапов работ. Этапы сортируются по порядковому индексу, что обеспечивает правильную последовательность отображения.

Маршрутизация запроса к данной функции осуществляется через роутер catalog.router, представленный в листинге 3.18.

```typescript
router.get("/services", async (req, res) => {
  try {
    const services = await catalogService.getServiceTemplates();
    res.json({ services });
  } catch (error: any) {
    console.error("Get services error:", error);
    res.status(500).json({ message: "Ошибка при получении услуг" });
  }
});
```

Листинг 3.18 – Маршрут GET /api/catalog/services

Данный маршрут не защищён middleware аутентификации, что позволяет любому посетителю сайта получить информацию об услугах без необходимости регистрации или входа в систему.

На клиентской стороне информация об услугах отображается на главной странице приложения. Компонент HomePage загружает данные при монтировании и отображает карточки услуг с названием, описанием и списком этапов работ. Реализация получения данных представлена в листинге 3.19.

```typescript
export const HomePage = () => {
  const [services, setServices] = useState<ServiceTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    servicesApi.getAll()
      .then(({ services }) => setServices(services))
      .catch(console.error)
      .finally(() => setIsLoading(false));
  }, []);

  // ... рендеринг карточек услуг
};
```

Листинг 3.19 – Загрузка списка услуг на главной странице

Каждая услуга отображается в виде карточки с информацией о названии услуги, её описании и перечне основных этапов работ. Это позволяет потенциальным клиентам ознакомиться с предлагаемыми услугами автосервиса до регистрации в системе.

## 3.7 Реализация функций пользователя с ролью «клиент»

### 3.7.1 Создание заказа на ремонт

Основной функциональной задачей клиентской части приложения является предоставление пользователю (клиенту) возможности создать заказ на ремонт автомобиля. Для реализации данной функциональности на сервере была разработана функция createOrder сервиса orders.service, основная часть которой представлена в листинге 3.20.

```typescript
async createOrder(data: {
  title?: string;
  description?: string;
  customerId: string;
  vehicleGenerationId?: string;
  vehicleYear?: number;
  vehicleInfo?: string;
  serviceType: string;
  serviceTypeOther?: string;
  serviceTemplateId?: string;
}) {
  let title = data.title || "";
  if (!title && data.vehicleGenerationId) {
    const generation = await prisma.vehicleGeneration.findUnique({
      where: { id: data.vehicleGenerationId },
      include: {
        model: { include: { brand: true } },
      },
    });
    if (generation) {
      title = `${generation.model.brand.name} ${generation.model.name} ${generation.nameRu || generation.name}`;
      if (data.vehicleYear) {
        title += ` ${data.vehicleYear}`;
      }
    }
  }

  let stageTemplates: any[] = [];
  if (data.serviceTemplateId) {
    const serviceTemplate = await prisma.serviceTemplate.findUnique({
      where: { id: data.serviceTemplateId },
      include: {
        stageTemplates: { orderBy: { orderIndex: "asc" } },
      },
    });
    if (serviceTemplate) {
      stageTemplates = serviceTemplate.stageTemplates;
    }
  }

  const order = await prisma.order.create({
    data: {
      title: title || "Новый заказ",
      description: data.description || null,
      customerId: data.customerId,
      vehicleGenerationId: data.vehicleGenerationId || null,
      vehicleYear: data.vehicleYear || null,
      vehicleInfo: data.vehicleInfo || null,
      serviceType: data.serviceType,
      serviceTypeOther: data.serviceTypeOther || null,
      serviceTemplateId: data.serviceTemplateId || null,
      status: "pending",
      stages: stageTemplates.length > 0 ? {
        create: stageTemplates.map((template) => ({
          name: template.name,
          description: template.description || null,
          orderIndex: template.orderIndex,
          status: "pending",
          stageTemplateId: template.id,
        })),
      } : undefined,
    },
    include: {
      customer: { select: { id: true, email: true, fullName: true, phone: true } },
      stages: { orderBy: { orderIndex: "asc" } },
    },
  });

  return order;
}
```

Листинг 3.20 – Реализация функции createOrder

Функция обеспечивает создание нового заказа на ремонт с автоматическим формированием заголовка на основе выбранного автомобиля. Если клиент выбрал поколение автомобиля, система автоматически формирует заголовок заказа в формате «Марка Модель Поколение Год». При выборе шаблона услуги система автоматически создаёт этапы заказа на основе шаблонов этапов, связанных с выбранной услугой.

Входные данные проходят валидацию через Zod-схему, которая проверяет тип услуги (diagnostics, repair, maintenance, other), год выпуска автомобиля (от 1900 до текущего года) и корректность идентификаторов. При выборе типа «other» обязательно указание описания типа работы. Также выполняется валидация года выпуска относительно выбранного поколения автомобиля.

После создания заказа система автоматически отправляет уведомления всем администраторам о новом заказе через сервис уведомлений.

### 3.7.2 Просмотр списка заказов и их статуса

Клиент имеет возможность в любой момент получить список своих заказов с информацией о текущем статусе выполнения. Для реализации данной функциональности на сервере разработана функция getOrdersByCustomer, представленная в листинге 3.21.

```typescript
async getOrdersByCustomer(customerId: string) {
  const orders = await prisma.order.findMany({
    where: { customerId },
    include: {
      stages: {
        orderBy: { orderIndex: "asc" },
        include: {
          mechanic: {
            select: { id: true, fullName: true, email: true },
          },
        },
      },
    },
    orderBy: { createdAt: "desc" },
  });

  for (const order of orders) {
    if (order.vehicleGenerationId) {
      const generation = await prisma.vehicleGeneration.findUnique({
        where: { id: order.vehicleGenerationId },
        include: {
          model: { include: { brand: true } },
        },
      });
      (order as any).vehicleGeneration = generation;
    }
  }

  return orders;
}
```

Листинг 3.21 – Реализация функции getOrdersByCustomer

Функция возвращает все заказы текущего пользователя, отсортированные по дате создания в порядке убывания (новые заказы первыми). Для каждого заказа загружаются связанные этапы с информацией о назначенном механике, а также информация об автомобиле (марка, модель, поколение). Это позволяет клиенту видеть полную картину по всем своим заказам и отслеживать прогресс выполнения каждого этапа.

### 3.7.3 Отслеживание прогресса ремонта

После создания заказа клиент имеет возможность отслеживать прогресс выполнения работ в реальном времени. Система предоставляет детальную информацию о каждом этапе ремонта через функцию getOrderStages сервиса stages.service, представленную в листинге 3.22.

```typescript
async getOrderStages(orderId: string) {
  return prisma.orderStage.findMany({
    where: { orderId },
    include: {
      mechanic: {
        select: { id: true, fullName: true, email: true },
      },
      comments: {
        orderBy: { createdAt: "desc" },
        include: {
          author: {
            select: { id: true, fullName: true, email: true },
          },
        },
      },
      attachments: {
        orderBy: { createdAt: "desc" },
        include: {
          uploadedBy: {
            select: { id: true, fullName: true },
          },
        },
      },
    },
    orderBy: { orderIndex: "asc" },
  });
}
```

Листинг 3.22 – Реализация функции getOrderStages

Функция возвращает все этапы заказа с детальной информацией: назначенный механик, комментарии к этапу (отсортированные по дате создания), вложенные файлы (фотографии выполненных работ). Этапы сортируются по порядковому индексу (orderIndex), что обеспечивает корректное отображение последовательности работ.

Каждый этап имеет статус: pending (ожидает выполнения), in_progress (в работе), done (выполнен) или blocked (заблокирован). Клиент видит текущий статус каждого этапа, время начала и завершения работ, а также комментарии механика с приложенными фотографиями.

### 3.7.4 Ответ на предложения комплектующих

В процессе ремонта администратор может предложить клиенту комплектующие для этапа работ. Клиент имеет возможность принять или отклонить предложенные комплектующие через специальный маршрут. Реализация обработки ответа клиента представлена в роутере stages.router и включает проверку доступа, обновление статуса комплектующего и управление складскими остатками.

При подтверждении опционального комплектующего система автоматически списывает его со склада. При отклонении ранее подтверждённого комплектующего – возвращает на склад. Обязательные комплектующие списываются автоматически при добавлении администратором.

### 3.7.5 Редактирование профиля и удаление аккаунта

В разработанном приложении предусмотрена функциональность персонализации учётной записи пользователя, позволяющая клиенту редактировать личные данные, а также при необходимости полностью удалить свой аккаунт.

Обновление профиля реализовано в функции updateUserProfile, представленной в листинге 3.23.

```typescript
export async function updateUserProfile(
  userId: string,
  data: { fullName?: string; phone?: string; email?: string },
): Promise<AuthUser> {
  if (data.email) {
    const existing = await prisma.user.findFirst({
      where: {
        email: data.email,
        id: { not: userId },
      },
    });

    if (existing) {
      throw new Error("Пользователь с таким email уже существует");
    }
  }

  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      ...(data.fullName && { fullName: data.fullName }),
      ...(data.phone !== undefined && { phone: data.phone }),
      ...(data.email && { email: data.email }),
    },
  });

  return {
    id: user.id,
    email: user.email,
    fullName: user.fullName,
    role: user.role as UserRole,
    phone: user.phone,
  };
}
```

Листинг 3.23 – Реализация функции updateUserProfile

Функция позволяет обновить полное имя, номер телефона и email пользователя. При изменении email выполняется проверка на уникальность – система не позволит использовать email, уже занятый другим пользователем.

Смена пароля реализована в функции changeUserPassword, которая требует указания текущего пароля для подтверждения операции. Новый пароль хешируется с использованием bcryptjs перед сохранением в базу данных.

Удаление аккаунта реализовано как soft delete через функцию deleteUserAccount, представленную в листинге 3.24.

```typescript
export async function deleteUserAccount(userId: string): Promise<void> {
  await prisma.user.update({
    where: { id: userId },
    data: { isActive: false },
  });
}
```

Листинг 3.24 – Реализация функции deleteUserAccount

При удалении аккаунта устанавливается флаг isActive = false, что деактивирует учётную запись без физического удаления данных из базы. Это позволяет сохранить историю заказов и обеспечивает возможность восстановления аккаунта при необходимости. После удаления аккаунта cookies с токенами очищаются, и пользователь автоматически выходит из системы.

## 3.8 Реализация функций пользователя с ролью «механик»

### 3.8.1 Просмотр назначенных заказов

Пользователю с ролью «механик» предоставлена возможность просмотра всех назначенных ему заказов. Для реализации данной функциональности на сервере разработана функция getAssignedOrders сервиса stages.service, представленная в листинге 3.25.

```typescript
async getAssignedOrders(mechanicId: string) {
  const stages = await prisma.orderStage.findMany({
    where: { assignedTo: mechanicId },
    include: {
      order: {
        include: {
          customer: {
            select: { id: true, fullName: true, email: true, phone: true },
          },
          stages: {
            orderBy: { orderIndex: "asc" },
            include: {
              mechanic: {
                select: { id: true, fullName: true, email: true },
              },
              comments: {
                orderBy: { createdAt: "desc" },
                take: 3,
                include: {
                  author: {
                    select: { id: true, fullName: true },
                  },
                },
              },
            },
          },
        },
      },
    },
    orderBy: { createdAt: "desc" },
  });

  for (const stage of stages) {
    if (stage.order.vehicleGenerationId) {
      const generation = await prisma.vehicleGeneration.findUnique({
        where: { id: stage.order.vehicleGenerationId },
        include: {
          model: { include: { brand: true } },
        },
      });
      (stage.order as any).vehicleGeneration = generation;
    }
  }

  const orderMap = new Map();
  stages.forEach((stage) => {
    if (!orderMap.has(stage.orderId)) {
      orderMap.set(stage.orderId, {
        ...stage.order,
        assignedStages: [],
        timeline: stage.order.stages,
      });
    }
    orderMap.get(stage.orderId).assignedStages.push(stage);
  });

  return Array.from(orderMap.values());
}
```

Листинг 3.25 – Реализация функции getAssignedOrders

Функция выполняет поиск всех этапов, назначенных конкретному механику по его идентификатору. Для каждого этапа загружается связанный заказ с полной информацией о клиенте (имя, email, телефон), всех этапах заказа с их статусами и назначенными механиками, а также последними комментариями. Дополнительно загружается информация об автомобиле клиента (марка, модель, поколение).

Результаты группируются по заказам, что позволяет механику видеть все назначенные ему этапы в контексте соответствующих заказов. Это обеспечивает удобный обзор рабочей нагрузки и позволяет планировать выполнение работ.

### 3.8.2 Отметка выполнения этапов ремонта

Механик имеет возможность обновлять статус назначенных ему этапов ремонта. Для реализации данной функциональности разработана функция updateStageStatus сервиса stages.service, представленная в листинге 3.26.

```typescript
async updateStageStatus(
  stageId: string,
  mechanicId: string,
  data: {
    status: "pending" | "in_progress" | "done" | "blocked";
    comment?: string;
  },
) {
  const stage = await prisma.orderStage.findUnique({
    where: { id: stageId },
    include: { order: true },
  });

  if (!stage) {
    throw new Error("Этап не найден");
  }

  if (stage.assignedTo && stage.assignedTo !== mechanicId) {
    throw new Error("Этап назначен другому механику");
  }

  const updateData: any = {
    status: data.status,
    assignedTo: mechanicId,
  };

  if (data.status === "in_progress" && !stage.startedAt) {
    updateData.startedAt = new Date();
  }

  if (data.status === "done" && !stage.completedAt) {
    updateData.completedAt = new Date();
  }

  const updatedStage = await prisma.orderStage.update({
    where: { id: stageId },
    data: updateData,
    include: {
      mechanic: {
        select: { id: true, fullName: true, email: true },
      },
    },
  });

  if (data.comment) {
    await prisma.stageComment.create({
      data: {
        stageId: stageId,
        authorId: mechanicId,
        content: data.comment,
      },
    });
  }

  if (data.status === "done" && stage.status !== "done") {
    await notificationsService.create({
      userId: stage.order.customerId,
      orderId: stage.orderId,
      type: "stage_done",
      title: `Этап "${stage.name}" завершён`,
      message: `Заказ: ${stage.order.title}`,
      metadata: { stageId, stageName: stage.name, orderTitle: stage.order.title },
    });
  }

  const allStages = await prisma.orderStage.findMany({
    where: { orderId: stage.orderId },
  });

  const allDone = allStages.every((s) => s.status === "done");
  if (allDone) {
    await prisma.order.update({
      where: { id: stage.orderId },
      data: { status: "completed", completedAt: new Date() },
    });
  }

  return updatedStage;
}
```

Листинг 3.26 – Реализация функции updateStageStatus

Функция позволяет механику изменять статус этапа на один из четырёх возможных значений: pending (ожидает выполнения), in_progress (в работе), done (выполнен) или blocked (заблокирован). При переходе этапа в статус «в работе» автоматически фиксируется время начала работ (startedAt), при завершении – время завершения (completedAt).

Система выполняет проверку прав доступа: механик может обновлять только те этапы, которые назначены ему. При попытке обновить этап, назначенный другому механику, возвращается ошибка с кодом 403.

При завершении этапа система автоматически отправляет уведомление клиенту о выполнении работы. Если все этапы заказа завершены, статус заказа автоматически обновляется на «completed» (выполнен), и клиент получает уведомление о полном завершении ремонта.

### 3.8.3 Добавление комментариев к этапам

Механик имеет возможность добавлять комментарии к этапам ремонта для документирования хода выполнения работ. Для реализации данной функциональности разработана функция addComment сервиса stages.service, представленная в листинге 3.27.

```typescript
async addComment(stageId: string, authorId: string, content: string) {
  return prisma.stageComment.create({
    data: {
      stageId,
      authorId,
      content,
    },
    include: {
      author: {
        select: {
          id: true,
          fullName: true,
          email: true,
        },
      },
    },
  });
}
```

Листинг 3.27 – Реализация функции addComment

Функция создаёт новую запись комментария в таблице StageComment, связывая её с конкретным этапом и автором. Комментарий содержит текстовое содержимое и автоматически получает временную метку создания. При создании комментария загружается информация об авторе (имя, email) для отображения в интерфейсе.

Комментарии позволяют механику фиксировать важную информацию о ходе работ: обнаруженные проблемы, причины задержек, рекомендации клиенту. Клиент может видеть все комментарии при отслеживании прогресса ремонта.

### 3.8.4 Возможность прикрепления фото/отчётов по выполненным работам

Механик имеет возможность прикреплять фотографии и отчёты к этапам ремонта. Для реализации данной функциональности разработана функция addAttachment сервиса stages.service, представленная в листинге 3.25.

```typescript
async addAttachment(stageId: string, uploadedById: string, payload: {
  base64: string;
  fileName?: string;
  description?: string;
  mimeType?: string;
}) {
  const saved = await saveBase64File({
    base64: payload.base64,
    fileName: payload.fileName,
  });

  return prisma.stageAttachment.create({
    data: {
      stageId,
      uploadedById,
      fileName: payload.fileName || "attachment",
      filePath: saved.relativePath,
      fileSize: saved.size,
      mimeType: payload.mimeType || null,
      description: payload.description || null,
    },
    include: {
      uploadedBy: {
        select: {
          id: true,
          fullName: true,
        },
      },
    },
  });
}
```

Листинг 3.28 – Реализация функции addAttachment

Функция принимает файл в формате Base64, сохраняет его на сервере через утилиту saveBase64File и создаёт запись в таблице StageAttachment. Каждое вложение содержит информацию о файле: имя, путь на сервере, размер, MIME-тип и опциональное описание. Также сохраняется информация о пользователе, загрузившем файл.

Механик может прикреплять фотографии выполненных работ, сканы документов, отчёты о диагностике. Это обеспечивает прозрачность процесса ремонта для клиента и создаёт документальное подтверждение выполненных работ.

## 3.9 Реализация функций пользователя с ролью «администратор»

### 3.9.1 Создание, изменение, удаление этапов ремонта

Пользователю с ролью «администратор» предоставлен полный функционал для управления этапами ремонта в заказах клиентов. Для создания нового этапа разработана функция createStage сервиса stages.service, представленная в листинге 3.26.

```typescript
async createStage(orderId: string, data: {
  name: string;
  description?: string;
  orderIndex?: number;
  assignedTo?: string;
}) {
  const order = await prisma.order.findUnique({ where: { id: orderId } });
  if (!order) {
    throw new Error("Заказ не найден");
  }

  let orderIndex = data.orderIndex;
  if (orderIndex === undefined) {
    const aggregate = await prisma.orderStage.aggregate({
      where: { orderId },
      _max: { orderIndex: true },
    });
    orderIndex = (aggregate._max.orderIndex ?? -1) + 1;
  }

  const stage = await prisma.orderStage.create({
    data: {
      orderId,
      name: data.name,
      description: data.description || null,
      orderIndex,
      status: "pending",
      assignedTo: data.assignedTo || null,
    },
    include: {
      mechanic: {
        select: { id: true, fullName: true, email: true },
      },
    },
  });

  if (data.assignedTo) {
    await notificationsService.create({
      userId: data.assignedTo,
      orderId,
      type: "stage_assigned",
      title: "Новый этап назначен",
      message: `Вам назначен этап "${data.name}" для заказа "${order.title}"`,
      metadata: {
        stageId: stage.id,
        stageName: data.name,
        orderTitle: order.title,
      },
    });
  }

  return stage;
}
```

Листинг 3.29 – Реализация функции createStage

Функция создаёт новый этап ремонта для указанного заказа. Администратор может указать название этапа (например: «диагностика двигателя», «замена охлаждающей жидкости», «замена масла»), описание и сразу назначить механика для выполнения. Порядковый индекс этапа автоматически вычисляется на основе существующих этапов, что обеспечивает корректную последовательность работ.

При назначении механика система автоматически отправляет ему уведомление о новом назначенном этапе с информацией о заказе.

Для обновления этапа разработана функция updateStage, которая позволяет изменять название, описание, статус и назначенного механика. Функция представлена в листинге 3.27.

```typescript
async updateStage(stageId: string, data: {
  name?: string;
  description?: string;
  status?: "pending" | "in_progress" | "done" | "blocked";
  assignedTo?: string | null;
  orderIndex?: number;
}) {
  const existing = await prisma.orderStage.findUnique({
    where: { id: stageId },
    include: { order: true },
  });

  if (!existing) {
    throw new Error("Этап не найден");
  }

  const updatePayload: any = { ...data };
  const isNewAssignment = data.assignedTo !== undefined &&
    data.assignedTo !== existing.assignedTo && data.assignedTo !== null;

  if (data.assignedTo !== undefined && data.assignedTo !== existing.assignedTo) {
    updatePayload.assignedTo = data.assignedTo;
    updatePayload.lastViewedAt = null;
  }

  const updatedStage = await prisma.orderStage.update({
    where: { id: stageId },
    data: updatePayload,
    include: {
      mechanic: {
        select: { id: true, fullName: true, email: true },
      },
    },
  });

  if (isNewAssignment && data.assignedTo) {
    await notificationsService.create({
      userId: data.assignedTo,
      orderId: existing.orderId,
      type: "stage_assigned",
      title: "Этап назначен вам",
      message: `Вам назначен этап "${existing.name}" для заказа "${existing.order.title}"`,
      metadata: { stageId, stageName: existing.name, orderTitle: existing.order.title },
    });
  }

  if (data.status === "done" && existing.status !== "done") {
    await notificationsService.create({
      userId: existing.order.customerId,
      orderId: existing.orderId,
      type: "stage_done",
      title: `Этап "${existing.name}" завершён`,
      message: `Заказ: ${existing.order.title}`,
      metadata: { stageId, stageName: existing.name, orderTitle: existing.order.title },
    });
  }

  return updatedStage;
}
```

Листинг 3.30 – Реализация функции updateStage

Функция позволяет администратору изменять параметры этапа: название, описание, статус и назначенного механика. При назначении нового механика система автоматически сбрасывает время последнего просмотра этапа и отправляет уведомление новому исполнителю. При изменении статуса на «выполнен» клиент получает уведомление о завершении этапа.

Для удаления этапа разработана функция deleteStage, представленная в листинге 3.31.

```typescript
async deleteStage(stageId: string) {
  const stage = await prisma.orderStage.findUnique({
    where: { id: stageId },
    include: {
      inventoryItems: true,
    },
  });

  if (!stage) {
    throw new Error("Этап не найден");
  }

  for (const item of stage.inventoryItems) {
    if (item.isRequired || item.selectedByClient) {
      await prisma.inventoryItem.update({
        where: { id: item.inventoryItemId },
        data: {
          stock: { increment: item.quantity },
        },
      });
    }
  }

  await prisma.$transaction([
    prisma.orderStageInventoryItem.deleteMany({ where: { orderStageId: stageId } }),
    prisma.stageComment.deleteMany({ where: { stageId } }),
    prisma.stageAttachment.deleteMany({ where: { stageId } }),
    prisma.orderStage.delete({ where: { id: stageId } }),
  ]);

  return { success: true };
}
```

Листинг 3.31 – Реализация функции deleteStage

Функция выполняет каскадное удаление этапа со всеми связанными данными: комплектующими, комментариями и вложениями. При удалении этапа комплектующие, которые были списаны со склада (обязательные или одобренные клиентом), автоматически возвращаются на склад. Использование транзакции обеспечивает атомарность операции и предотвращает частичное удаление данных при возникновении ошибок.

### 3.9.2 Предоставление клиенту выбора комплектующих и расходных материалов на этапах выполнения работ

Администратор имеет возможность предлагать клиенту комплектующие и расходные материалы для каждого этапа ремонта. Для реализации данной функциональности разработана функция suggestInventoryForOrderStage сервиса admin.service, представленная в листинге 3.32.

```typescript
async suggestInventoryForOrderStage(data: {
  orderStageId: string;
  inventoryItemId: string;
  quantity?: number;
  isRequired?: boolean;
  adminNotes?: string;
}) {
  const stage = await prisma.orderStage.findUnique({
    where: { id: data.orderStageId },
    include: {
      order: {
        include: {
          vehicleGeneration: {
            include: {
              model: { include: { brand: true } },
            },
          },
        },
      },
    },
  });

  if (!stage) {
    throw new Error("Этап не найден");
  }

  const inventoryItem = await prisma.inventoryItem.findUnique({
    where: { id: data.inventoryItemId },
  });

  if (!inventoryItem) {
    throw new Error("Комплектующее не найдено");
  }

  const quantity = data.quantity || 1;

  if (inventoryItem.stock < quantity) {
    throw new Error(`Недостаточно товара на складе. Доступно: ${inventoryItem.stock}, требуется: ${quantity}`);
  }

  if (data.isRequired) {
    await prisma.inventoryItem.update({
      where: { id: data.inventoryItemId },
      data: {
        stock: { decrement: quantity },
      },
    });
  }

  const suggestion = await prisma.orderStageInventoryItem.create({
    data: {
      orderStageId: data.orderStageId,
      inventoryItemId: data.inventoryItemId,
      quantity: quantity,
      isRequired: data.isRequired || false,
      adminNotes: data.adminNotes,
      unitPrice: inventoryItem.price,
      suggestedByAdmin: true,
      status: "pending",
    },
    include: {
      inventoryItem: true,
    },
  });

  await notificationsService.create({
    userId: stage.order.customerId,
    orderId: stage.orderId,
    type: "inventory_suggested",
    title: "Предложены комплектующие",
    message: `Администратор предложил "${inventoryItem.name}" для этапа "${stage.name}"`,
    metadata: {
      stageId: stage.id,
      stageName: stage.name,
      orderTitle: stage.order.title,
      inventoryItemName: inventoryItem.name,
      quantity: data.quantity || 1,
    },
  });

  return suggestion;
}
```

Листинг 3.32 – Реализация функции suggestInventoryForOrderStage

Функция позволяет администратору предложить клиенту комплектующее для конкретного этапа ремонта. При добавлении комплектующего указывается количество, цена (берётся из справочника) и признак обязательности.

Комплектующие могут быть двух типов:
- **Обязательные** (isRequired = true) – необходимы для выполнения работ, автоматически списываются со склада при добавлении.
- **Опциональные** (isRequired = false) – предлагаются клиенту на выбор, списываются со склада только после подтверждения клиентом.

Система проверяет наличие товара на складе перед добавлением. При недостаточном количестве возвращается ошибка с информацией о доступном остатке.

После добавления комплектующего клиент получает уведомление с информацией о предложенной детали и этапе, к которому она относится. Клиент может просмотреть все предложенные комплектующие в интерфейсе отслеживания заказа и принять или отклонить опциональные позиции.

Для управления предложенными комплектующими также реализованы функции обновления и удаления. При удалении комплектующего из этапа товар автоматически возвращается на склад, если он был списан ранее (обязательное комплектующее или одобренное клиентом опциональное).

---

## 4 ТЕСТИРОВАНИЕ WEB-ПРИЛОЖЕНИЯ

Тестирование является неотъемлемой частью разработки программного обеспечения, обеспечивающей качество и надёжность создаваемого продукта. В рамках данной работы проведено функциональное тестирование системы CURSED для отслеживания статуса ремонта автомобилей.

Тестирование проводилось методом чёрного ящика (black-box testing), при котором проверяется соответствие поведения системы требованиям технического задания. Для каждой функции был разработан тестовый сценарий, включающий шаги выполнения и ожидаемый результат.

### 4.1 Функциональное тестирование

Функциональное тестирование проводилось в соответствии с требованиями технического задания. Результаты тестирования представлены в таблице 4.1.

## Таблица 4.1 – Результаты функционального тестирования

| № | Функция | Описание тестирования | Ожидаемый результат |
|---|---------|----------------------|---------------------|
| 1 | Регистрация в системе | Под ролью «Гость» открыть страницу авторизации (/login). Нажать ссылку «Зарегистрироваться». Ввести корректный email (newuser@test.com), пароль (123456), подтверждение пароля (123456) и ФИО (Тестовый Пользователь). Нажать кнопку «Зарегистрироваться». | Появляется сообщение об успешной регистрации. Пользователь перенаправлен на страницу входа. |
| 2 | Валидация регистрации (email) | Под ролью «Гость» открыть страницу регистрации. Ввести некорректный email (test). Попытаться отправить форму. | Форма не отправляется. Отображается сообщение об ошибке валидации email. |
| 3 | Валидация регистрации (пароль) | Под ролью «Гость» открыть страницу регистрации. Ввести корректный email, но пароль менее 6 символов (123). Попытаться отправить форму. | Форма не отправляется. Отображается сообщение о минимальной длине пароля. |
| 4 | Аутентификация (успешная) | Под ролью «Гость» открыть страницу авторизации (/login). Ввести email (client@autotrack.local) и пароль (password123). Нажать кнопку «Войти». | Пользователь авторизован и перенаправлен на страницу /client. В шапке отображается имя пользователя. |
| 5 | Аутентификация (неверный пароль) | Под ролью «Гость» открыть страницу авторизации (/login). Ввести email (client@autotrack.local) и неверный пароль (wrongpassword). Нажать кнопку «Войти». | Отображается сообщение об ошибке «Неверный email или пароль». Пользователь остаётся на странице входа. |
| 6 | Просмотр услуг на главной | Под ролью «Гость» открыть главную страницу (/). Прокрутить до раздела «Наши услуги». | Отображаются карточки услуг: «Диагностика двигателя», «Замена масла», «Ремонт тормозной системы» и другие с описаниями и этапами работ. |
| 7 | Создание заказа | Под ролью «Клиент» авторизоваться (client@autotrack.local / password123). Нажать кнопку «Новый заказ». Выбрать марку (BMW), модель (3 Series), поколение (E90). Указать год выпуска (2010). Выбрать тип услуги «Диагностика». Нажать кнопку «Создать заказ». | Заказ создан. Отображается в списке заказов со статусом «В ожидании». |
| 8 | Создание заказа (другой тип услуги) | Под ролью «Клиент» авторизоваться. Нажать кнопку «Новый заказ». Выбрать марку (Toyota), модель (Camry), поколение (XV70). Указать год (2020). Выбрать тип услуги «Другое», ввести описание «Замена стекла». Нажать «Создать заказ». | Заказ создан с типом услуги «Другое» и указанным описанием. |
| 9 | Просмотр списка заказов | Под ролью «Клиент» авторизоваться и перейти на страницу /client. | Отображается список заказов с информацией: автомобиль, тип услуги, статус, дата создания. Заказы отсортированы по дате (новые сверху). |
| 10 | Просмотр прогресса заказа | Под ролью «Клиент» открыть страницу /client. Нажать на карточку заказа для раскрытия деталей. | Отображается список этапов заказа с индикаторами статуса (цветные метки) и информацией о назначенных механиках. |
| 11 | Просмотр комментариев к этапу | Под ролью «Клиент» открыть заказ с комментариями. Развернуть этап с комментариями. | Отображаются комментарии механика с текстом, именем автора и датой добавления. |
| 12 | Просмотр вложений к этапу | Под ролью «Клиент» открыть заказ с вложениями. Развернуть этап с прикреплёнными файлами. | Отображаются вложения (фотографии) с возможностью просмотра и скачивания. |
| 13 | Выбор опционального комплектующего | Под ролью «Клиент» открыть заказ с предложенными комплектующими. Найти опциональное комплектующее. Нажать кнопку «Выбрать». | Комплектующее отмечено как выбранное (статус «approved»). Сумма заказа обновлена. |
| 14 | Отказ от комплектующего | Под ролью «Клиент» открыть заказ с предложенными комплектующими. Найти опциональное комплектующее. Нажать кнопку «Отказаться». | Комплектующее отмечено как отклонённое (статус «rejected»). |
| 15 | Обновление профиля (ФИО) | Под ролью «Клиент» перейти на страницу /profile. Изменить ФИО на «Новое Имя». Нажать кнопку «Сохранить изменения». | Отображается сообщение об успешном обновлении. Новое имя видно в шапке сайта. |
| 16 | Обновление профиля (телефон) | Под ролью «Клиент» перейти на страницу /profile. Ввести номер телефона (+7 999 123-45-67). Нажать «Сохранить изменения». | Номер телефона сохранён и отображается в профиле. |
| 17 | Смена пароля | Под ролью «Клиент» перейти на страницу /profile. Ввести текущий пароль (password123), новый пароль (newpass123) и подтверждение. Нажать «Сменить пароль». | Пароль изменён. Можно войти с новым паролем. |
| 18 | Просмотр уведомлений | Под ролью «Клиент» нажать на иконку колокольчика в шапке сайта. | Открывается панель уведомлений со списком событий по заказам (новые этапы, изменения статусов, предложенные комплектующие). |
| 19 | Отметка уведомления как прочитанного | Под ролью «Клиент» открыть панель уведомлений. Нажать на непрочитанное уведомление. | Уведомление отмечено как прочитанное. Счётчик непрочитанных уменьшается. |
| 20 | Просмотр назначенных этапов | Под ролью «Механик» авторизоваться (mechanic@autotrack.local / password123). Перейти на страницу /mechanic. | Отображается список заказов с этапами, назначенными на текущего механика. Показаны: клиент, автомобиль, название этапа, статус. |
| 21 | Изменение статуса на «В работе» | Под ролью «Механик» открыть назначенный этап со статусом «В ожидании». Изменить статус на «В работе». Нажать «Сохранить». | Статус этапа изменён на «В работе». Записывается время начала работы. Клиент получает уведомление. |
| 22 | Изменение статуса на «Завершён» | Под ролью «Механик» открыть назначенный этап со статусом «В работе». Изменить статус на «Завершён». Нажать «Сохранить». | Статус этапа изменён на «Завершён». Записывается время завершения. Клиент получает уведомление. |
| 23 | Добавление комментария к этапу | Под ролью «Механик» открыть назначенный этап. Ввести текст комментария «Выполнена диагностика, обнаружены ошибки P0300». Нажать «Добавить комментарий». | Комментарий добавлен к этапу. Отображается текст, имя автора и время добавления. |
| 24 | Прикрепление фотографии | Под ролью «Механик» открыть этап. Нажать «Добавить вложение». Выбрать файл изображения (photo.jpg). Ввести описание «Фото диагностики». Нажать «Загрузить». | Файл загружен. Отображается в списке вложений с названием и описанием. |
| 25 | Просмотр всех заказов | Под ролью «Администратор» авторизоваться (admin@autotrack.local / password123). Перейти на страницу /admin. | Отображается список всех заказов системы с информацией: клиент, автомобиль, тип услуги, статус, прогресс. |
| 26 | Фильтрация заказов по статусу | Под ролью «Администратор» на странице /admin выбрать фильтр «В работе» в выпадающем списке статусов. | Отображаются только заказы со статусом «В работе». |
| 27 | Поиск заказа | Под ролью «Администратор» на странице /admin ввести в поле поиска «BMW». | Отображаются только заказы с автомобилями марки BMW. |
| 28 | Создание этапа ремонта | Под ролью «Администратор» открыть заказ. Нажать «Добавить этап». Ввести название «Диагностика ходовой части». Выбрать механика из списка. Нажать «Создать». | Этап создан и добавлен к заказу. Механик получает уведомление о назначении. |
| 29 | Редактирование этапа | Под ролью «Администратор» открыть заказ. Нажать на существующий этап. Изменить название на «Замена передних колодок». Нажать «Сохранить». | Название этапа обновлено и отображается в списке. |
| 30 | Переназначение механика | Под ролью «Администратор» открыть этап. Изменить назначенного механика на другого из списка. Нажать «Сохранить». | Механик изменён. Новый механик получает уведомление о назначении. |
| 31 | Удаление этапа | Под ролью «Администратор» открыть заказ с несколькими этапами. Нажать кнопку удаления (🗑) у этапа. Подтвердить удаление. | Этап удалён из списка. Комментарии и вложения удалены. |
| 32 | Добавление обязательного комплектующего | Под ролью «Администратор» открыть этап заказа. Нажать «Добавить комплектующее». Выбрать «Масло моторное 5W-30». Указать количество: 4. Отметить «Обязательное». Нажать «Добавить». | Комплектующее добавлено. Товар списан со склада. Остаток на складе уменьшен на 4. |
| 33 | Добавление опционального комплектующего | Под ролью «Администратор» открыть этап заказа. Нажать «Добавить комплектующее». Выбрать «Фильтр воздушный». Указать количество: 1. Не отмечать «Обязательное». Нажать «Добавить». | Комплектующее добавлено как опциональное. Клиент получает уведомление с предложением выбрать. |
| 34 | Удаление комплектующего из этапа | Под ролью «Администратор» открыть этап с комплектующим. Нажать кнопку удаления у комплектующего. Подтвердить. | Комплектующее удалено из этапа. Если было списано — товар возвращён на склад. |
| 35 | Управление шаблонами услуг | Под ролью «Администратор» перейти в раздел «Управление услугами» (/admin/services). | Отображается список шаблонов услуг с возможностью создания, редактирования и удаления. |
| 36 | Управление складом | Под ролью «Администратор» перейти в раздел «Склад» (/admin/inventory). | Отображается список комплектующих на складе с информацией: название, артикул, количество, цена. |
| 37 | Добавление товара на склад | Под ролью «Администратор» в разделе «Склад» нажать «Добавить товар». Заполнить: название, артикул (SKU), количество, цена. Нажать «Сохранить». | Товар добавлен на склад и отображается в списке. |
| 38 | Редактирование количества на складе | Под ролью «Администратор» в разделе «Склад» найти товар. Изменить количество. Нажать «Сохранить». | Количество товара обновлено. |
| 39 | Управление пользователями | Под ролью «Администратор» перейти в раздел «Пользователи» (/admin/users). | Отображается список пользователей системы с возможностью изменения ролей и статуса активности. |
| 40 | Изменение роли пользователя | Под ролью «Администратор» в разделе «Пользователи» найти пользователя. Изменить роль с «Клиент» на «Механик». Сохранить. | Роль пользователя изменена. Пользователь получает доступ к интерфейсу механика. |
| 41 | Деактивация пользователя | Под ролью «Администратор» в разделе «Пользователи» найти пользователя. Нажать «Деактивировать». | Учётная запись деактивирована. Пользователь не может войти в систему. |
| 42 | Выход из системы (Клиент) | Под ролью «Клиент» нажать кнопку «Выйти» в шапке сайта. | Пользователь разлогинен. Перенаправлен на страницу /login. Токены удалены из localStorage. |
| 43 | Выход из системы (Механик) | Под ролью «Механик» нажать кнопку «Выйти» в шапке сайта. | Пользователь разлогинен. Перенаправлен на страницу /login. |
| 44 | Выход из системы (Администратор) | Под ролью «Администратор» нажать кнопку «Выйти» в шапке сайта. | Пользователь разлогинен. Перенаправлен на страницу /login. |
| 45 | Контроль доступа (Клиент → Админ) | Под ролью «Клиент» попытаться открыть страницу /admin напрямую через адресную строку. | Доступ запрещён. Пользователь перенаправлен на страницу /client. |
| 46 | Контроль доступа (Клиент → Механик) | Под ролью «Клиент» попытаться открыть страницу /mechanic напрямую через адресную строку. | Доступ запрещён. Пользователь перенаправлен на страницу /client. |
| 47 | Контроль доступа (Механик → Админ) | Под ролью «Механик» попытаться открыть страницу /admin напрямую через адресную строку. | Доступ запрещён. Пользователь перенаправлен на страницу /mechanic. |
| 48 | Контроль доступа (Гость → Клиент) | Под ролью «Гость» (без авторизации) попытаться открыть страницу /client напрямую. | Доступ запрещён. Пользователь перенаправлен на страницу /login. |
| 49 | Адаптивная вёрстка (мобильный) | Под любой ролью открыть приложение на устройстве с шириной экрана 375px (мобильный телефон). | Интерфейс корректно отображается. Меню сворачивается в «гамбургер». Все элементы доступны. |
| 50 | Адаптивная вёрстка (планшет) | Под любой ролью открыть приложение на устройстве с шириной экрана 768px (планшет). | Интерфейс корректно отображается. Боковое меню доступно. Карточки адаптируются под размер экрана. |

---

### 4.2 Выводы по разделу

В ходе функционального тестирования web-приложения CURSED для отслеживания статуса ремонта автомобилей были проверены все основные функциональные возможности системы.

Тестирование охватило следующие категории функций:
- **Функции гостя** (6 тестов): регистрация с валидацией, аутентификация (успешная и с ошибкой), просмотр услуг.
- **Функции клиента** (13 тестов): создание заказов, просмотр прогресса и этапов, работа с комментариями и вложениями, выбор комплектующих, управление профилем, уведомления.
- **Функции механика** (5 тестов): просмотр назначенных работ, изменение статусов этапов, добавление комментариев и прикрепление файлов.
- **Функции администратора** (17 тестов): управление заказами, этапами ремонта, комплектующими, шаблонами услуг, складом и пользователями.
- **Общие функции** (9 тестов): выход из системы для всех ролей, контроль доступа, адаптивная вёрстка.

Всего выполнено **50 тестовых сценариев**. Все тесты завершились успешно, что подтверждает соответствие разработанного приложения требованиям технического задания.

Результаты тестирования подтверждают, что разработанное web-приложение полностью реализует заявленную функциональность и готово к эксплуатации.

---

## 5 РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ

### 5.1 Регистрация и аутентификация

Для начала работы с системой CURSED пользователю необходимо пройти процедуру регистрации или аутентификации. При первом посещении приложения пользователь попадает на главную страницу, где отображается информация об автосервисе и доступных услугах.

Для регистрации необходимо нажать кнопку «Войти» в правом верхнем углу экрана, после чего откроется страница авторизации. На данной странице следует выбрать ссылку «Зарегистрироваться», расположенную под формой входа. Визуальное представление страницы регистрации приведено на рисунке 5.1.

Рисунок 5.1 – Страница регистрации

На странице регистрации пользователь заполняет форму, указывая следующие данные: адрес электронной почты, пароль (минимум 6 символов), подтверждение пароля и ФИО. После заполнения всех обязательных полей и нажатия кнопки «Зарегистрироваться» происходит создание учётной записи. При успешной регистрации пользователь перенаправляется на страницу входа.

Для аутентификации пользователь вводит адрес электронной почты и пароль на странице входа, после чего нажимает кнопку «Войти». При успешной аутентификации происходит автоматическое перенаправление на соответствующую страницу в зависимости от роли пользователя: клиенты перенаправляются на страницу /client, механики — на /mechanic, администраторы — на /admin.

### 5.2 Руководство для роли «Клиент»

После успешной аутентификации пользователь с ролью «Клиент» автоматически перенаправляется на страницу «Мои заказы». На данной странице отображается список всех заказов клиента с информацией о статусе выполнения каждого из них. Визуальное представление страницы «Мои заказы» приведено на рисунке 5.2.

Рисунок 5.2 – Страница «Мои заказы»

На странице «Мои заказы» каждый заказ представлен в виде карточки, содержащей информацию об автомобиле, типе услуги, текущем статусе и прогрессе выполнения. Прогресс отображается в виде процентной шкалы, показывающей долю завершённых этапов от общего количества.

Для создания нового заказа необходимо нажать кнопку «Новый заказ», расположенную в верхней части страницы. После нажатия открывается форма создания заказа. Визуальное представление формы приведено на рисунке 5.3.

Рисунок 5.3 – Форма создания заказа

При создании заказа пользователь последовательно выбирает марку автомобиля из выпадающего списка, после чего становится доступным выбор модели. После выбора модели появляется возможность указать поколение автомобиля и год выпуска. Далее пользователь выбирает тип услуги: «Диагностика», «Ремонт», «Техническое обслуживание» или «Другая проблема». При выборе типа «Другая проблема» отображается дополнительное поле для ввода описания требуемых работ. После заполнения всех полей и нажатия кнопки «Создать заказ» происходит сохранение заказа в системе.

Для просмотра детальной информации о заказе необходимо нажать на соответствующую карточку. При этом раскрывается список этапов ремонта с индикаторами статуса. Визуальное представление развёрнутой карточки заказа приведено на рисунке 5.4.

Рисунок 5.4 – Детальный просмотр заказа

Каждый этап заказа отображается с указанием названия, текущего статуса (ожидание, в работе, завершён) и имени назначенного механика. Статусы визуально различаются цветовой индикацией: жёлтый — ожидание, синий — в работе, зелёный — завершён.

При наличии комментариев или вложений к этапу пользователь может просмотреть их, нажав на соответствующий этап. Комментарии механиков отображаются с указанием автора и времени добавления. Вложения (фотографии) доступны для просмотра и скачивания.

Если администратор предложил комплектующие для заказа, клиент получает уведомление и может просмотреть предложенные детали. Для опциональных комплектующих доступны кнопки «Выбрать» и «Отказаться», позволяющие принять или отклонить предложение. Обязательные комплектующие добавляются автоматически.

Для просмотра уведомлений необходимо нажать на иконку колокольчика в правом верхнем углу экрана. Открывается панель уведомлений, содержащая информацию о событиях: создание новых этапов, изменение статусов, предложение комплектующих. Визуальное представление панели уведомлений приведено на рисунке 5.5.

Рисунок 5.5 – Панель уведомлений

Непрочитанные уведомления отмечаются специальным индикатором. При нажатии на уведомление оно отмечается как прочитанное, а счётчик непрочитанных сообщений уменьшается.

Для редактирования профиля пользователь переходит на страницу /profile через меню в шапке сайта. На странице профиля доступны следующие возможности: изменение ФИО, добавление или изменение номера телефона, смена пароля. Удаление аккаунта. Визуальное представление страницы профиля приведено на рисунке 5.6.

Рисунок 5.6 – Страница профиля

Для изменения данных пользователь вводит новые значения в соответствующие поля и нажимает кнопку «Сохранить изменения». При смене пароля необходимо указать текущий пароль, новый пароль и подтверждение нового пароля.

Для выхода из системы необходимо нажать кнопку «Выйти», расположенную в шапке сайта. После выхода пользователь перенаправляется на страницу авторизации.

### 5.3 Руководство для роли «Механик»

После успешной аутентификации пользователь с ролью «Механик» автоматически перенаправляется на страницу /mechanic, где отображается список заказов с этапами, назначенными на текущего механика. Визуальное представление главной страницы механика приведено на рисунке 5.7.

Рисунок 5.7 – Главная страница механика

На главной странице отображаются карточки заказов с информацией о клиенте, автомобиле и назначенных этапах. Для каждого этапа показаны название и текущий статус. Механик видит только те этапы, которые назначены непосредственно на него.

Для работы с этапом необходимо нажать на соответствующую карточку заказа, после чего открывается детальный просмотр. Визуальное представление страницы работы с этапом приведено на рисунке 5.8.

Рисунок 5.8 – Работа с этапом заказа

На странице работы с этапом механик может выполнять следующие действия:

1. **Изменение статуса этапа.** Для начала работы над этапом необходимо изменить статус с «Ожидание» на «В работе». После завершения работ статус изменяется на «Завершён». При каждом изменении статуса клиент автоматически получает уведомление.

2. **Добавление комментариев.** Механик может добавлять комментарии к этапу, описывая выполненные работы, обнаруженные проблемы или рекомендации. Для добавления комментария необходимо ввести текст в поле ввода и нажать кнопку «Добавить комментарий».

3. **Прикрепление файлов.** Для документирования работ механик может прикреплять фотографии к этапу. Для этого необходимо нажать кнопку «Добавить вложение», выбрать файл изображения, при необходимости добавить описание и нажать «Загрузить».

Все добавленные комментарии и вложения становятся доступны клиенту для просмотра в его личном кабинете.

Механик также имеет доступ к странице профиля для редактирования личных данных и панели уведомлений для получения информации о новых назначениях.

### 5.4 Руководство для роли «Администратор»

После успешной аутентификации пользователь с ролью «Администратор» автоматически перенаправляется на страницу /admin, где отображается полный список всех заказов в системе. Визуальное представление главной страницы администратора приведено на рисунке 5.9.

Рисунок 5.9 – Главная страница администратора

На главной странице администратора отображается таблица заказов с информацией о клиенте, автомобиле, типе услуги, статусе и прогрессе выполнения. Для удобства навигации предусмотрены инструменты фильтрации и поиска:

- **Фильтрация по статусу.** Выпадающий список позволяет отобразить заказы с определённым статусом: все, в ожидании, в работе, завершённые.
- **Поиск.** Поисковая строка позволяет находить заказы по названию автомобиля или имени клиента.

При нажатии на строку заказа открывается детальный просмотр с возможностью управления этапами. Визуальное представление страницы управления заказом приведено на рисунке 5.10.

Рисунок 5.10 – Управление заказом

На странице управления заказом администратор может выполнять следующие действия:

1. **Создание этапов.** Для добавления нового этапа необходимо нажать кнопку «Добавить этап», ввести название, выбрать механика из списка и нажать «Создать». Механик автоматически получает уведомление о назначении.

2. **Редактирование этапов.** Для изменения параметров этапа необходимо нажать на соответствующий этап, внести изменения (название, описание, назначенный механик) и сохранить.

3. **Удаление этапов.** Для удаления этапа необходимо нажать кнопку удаления и подтвердить действие. При удалении этапа все связанные комментарии и вложения также удаляются.

4. **Управление комплектующими.** Администратор может добавлять комплектующие к этапам заказа. Для этого необходимо открыть этап, нажать «Добавить комплектующее», выбрать товар из списка, указать количество и тип (обязательное или опциональное). Обязательные комплектующие автоматически списываются со склада, опциональные — после подтверждения клиентом.

Для управления складом необходимо перейти в раздел «Склад» через навигационное меню. Визуальное представление страницы склада приведено на рисунке 5.11.

Рисунок 5.11 – Управление складом

На странице склада отображается список всех комплектующих с информацией о названии, артикуле, количестве на складе и цене. Администратор может:

- **Добавлять новые товары.** Кнопка «Добавить товар» открывает форму для ввода данных о новом комплектующем.
- **Редактировать существующие товары.** Изменение количества, цены и других параметров.
- **Просматривать историю движения товаров.**

Для управления пользователями необходимо перейти в раздел «Пользователи». Визуальное представление страницы управления пользователями приведено на рисунке 5.12.

Рисунок 5.12 – Управление пользователями

На странице управления пользователями отображается список всех пользователей системы. Администратор может:

- **Изменять роли пользователей.** Назначать роли «Клиент», «Механик» или «Администратор».
- **Деактивировать учётные записи.** Заблокированные пользователи не могут войти в систему.
- **Активировать учётные записи.** Восстановление доступа для ранее заблокированных пользователей.

Для управления шаблонами услуг необходимо перейти в раздел «Управление услугами». На данной странице администратор может создавать, редактировать и удалять шаблоны услуг, а также настраивать этапы, входящие в каждую услугу.

### 5.5 Выводы по разделу

Руководство пользователя охватывает весь функционал приложения CURSED для отслеживания статуса ремонта автомобилей. Реализованы простые процессы регистрации, авторизации и изменения профиля.

Пользователи с ролью «Клиент» имеют доступ к основному функционалу приложения. Они могут создавать заказы на ремонт или обслуживание автомобиля, указывая марку, модель, поколение и год выпуска транспортного средства. Клиенты отслеживают прогресс выполнения заказа в режиме реального времени, просматривают комментарии и фотографии от механиков, а также принимают решения по предложенным комплектующим. Система уведомлений информирует клиентов обо всех важных событиях. Все эти действия направлены на обеспечение прозрачности и удобства взаимодействия с автосервисом.

Пользователи с ролью «Механик» обладают возможностями для выполнения и документирования ремонтных работ. Механики видят назначенные на них этапы заказов, могут изменять статусы выполнения, добавлять комментарии с описанием проведённых работ и прикреплять фотографии для фиксации результатов. Это позволяет обеспечить прозрачность процесса ремонта и своевременное информирование клиентов.

Пользователи с ролью «Администратор» обладают полным доступом к управлению системой. Администратор управляет всеми заказами, создаёт и редактирует этапы ремонта, назначает механиков, добавляет комплектующие из склада. Также администратор контролирует складские запасы, управляет пользователями системы и настраивает шаблоны услуг. Это обеспечивает эффективную координацию работы автосервиса и высокое качество обслуживания клиентов.

---

## ЗАКЛЮЧЕНИЕ

В результате выполнения данной работы было разработано современное web-приложение CURSED для отслеживания статуса ремонта автомобилей. Основной целью проекта являлась реализация полнофункциональной платформы, обеспечивающей прозрачное взаимодействие между клиентами автосервиса и персоналом, а также предоставляющей инструменты для управления заказами, отслеживания прогресса ремонтных работ и контроля складских запасов.

Разработка велась с применением современных технологий: на серверной стороне использован Node.js с фреймворком Express и ORM-библиотекой Prisma для взаимодействия с базой данных Microsoft SQL Server. Аутентификация и авторизация реализованы с использованием JWT (JSON Web Token) с поддержкой механизма обновления токенов (refresh tokens). Клиентская часть построена на React с использованием TypeScript, с применением TanStack Query для управления серверным состоянием и React Router для маршрутизации. Визуальный облик интерфейса был детально проработан с использованием Tailwind CSS, что позволило достичь гибкости в стилизации и адаптивности интерфейса для различных устройств.

Web-приложение поддерживает четыре основные роли: гость, клиент, механик и администратор, каждая из которых обладает собственным набором прав и функциональностью. Гости могут просматривать информацию об услугах автосервиса и регистрироваться в системе. Клиенты получают возможность создавать заказы на ремонт или обслуживание автомобиля, отслеживать прогресс выполнения работ в режиме реального времени, просматривать комментарии и фотографии от механиков, а также принимать решения по предложенным комплектующим. Механики имеют доступ к назначенным этапам работ, могут изменять статусы выполнения, документировать проведённые работы с помощью комментариев и фотографий. Администраторы обладают полным контролем над системой: управляют заказами, этапами ремонта, складскими запасами, пользователями и шаблонами услуг.

База данных проекта спроектирована таким образом, чтобы эффективно хранить информацию о заказах, этапах ремонта, комплектующих, пользователях и уведомлениях. В базе данных разработано 16 таблиц, обеспечивающих целостность данных и поддержку всех бизнес-процессов автосервиса. Реализована система уведомлений, информирующая пользователей о важных событиях: создании новых этапов, изменении статусов, предложении комплектующих и назначении на работы.

В ходе функционального тестирования было проверено корректное функционирование всех ключевых функций системы. Всего выполнено 50 тестовых сценариев, охватывающих регистрацию и авторизацию, создание и управление заказами, работу с этапами ремонта, систему комплектующих, управление складом и пользователями, а также контроль доступа по ролям. Все тесты завершились успешно, что подтверждает соответствие разработанного приложения требованиям технического задания.

Разработанное web-приложение представляет собой готовую платформу для автоматизации процессов автосервиса, обладающую гибкой архитектурой, масштабируемостью и удобным пользовательским интерфейсом. Система обеспечивает прозрачность взаимодействия между клиентами и персоналом, повышает эффективность управления ремонтными работами и способствует улучшению качества обслуживания клиентов.
